<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Epilepsy Seizure Diary Dashboard</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" />

  <!-- Plotly JS -->
  <script src="https://cdn.plot.ly/plotly-2.16.1.min.js"></script>
  
  <!-- Papa Parse for CSV -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- Flatpickr CSS and JS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

  <!-- SheetJS for Excel files -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>

  <style>
    body {
      font-family: Arial, sans-serif;
    }
    .chart-container {
      border: 1px solid #ccc;
      margin-bottom: 30px;
      padding: 10px;
    }
    .chart-title {
      font-weight: bold;
      margin-bottom: 10px;
    }
    /* This rule prevents shape overlays from intercepting mouse events */
    #heatmap .shapelayer {
      pointer-events: none;
    }
  </style>
</head>

<body class="bg-light">
<div class="container my-4">

  <h1 class="mb-4">Interactive Epilepsy Seizure Diary Data Dashboard</h1>

  <!-- Row: Controls -->
  <div class="row mb-4">
    <!-- Start Date -->
    <div class="col-md-2">
      <label for="startDate" class="form-label">Start Date:</label>
      <input type="date" id="startDate" class="form-control" />
    </div>

    <!-- End Date -->
    <div class="col-md-2">
      <label for="endDate" class="form-label">End Date:</label>
      <input type="date" id="endDate" class="form-control" />
    </div>

      <!-- Seizure Types (will be populated dynamically) -->
      <div class="col-md-3">
        <label for="seizureTypes" class="form-label">Seizures to Display:</label>
        <select id="seizureTypes" class="form-select" multiple style="min-width: 200px;">
          <!-- Options will be loaded from file data -->
        </select>
        <small class="text-muted">Hold Ctrl/Command to select multiple.</small>
      </div>
      <!-- Add this inside the "Row: Controls" div, right after the seizure types dropdown -->
      <div class="col-md-2">
        <label for="userSelect" class="form-label">User:</label>
        <select id="userSelect" class="form-select">
          <option value="all">All Users</option>
          <!-- Options will be populated dynamically -->
        </select>
      </div>
    <!-- Binning -->
    <div class="col-md-2">
      <label class="form-label">Heatmap Binning:</label>
      <div class="form-check">
        <input class="form-check-input" type="radio" name="binning" id="binWeekly" value="Weekly" />
        <label class="form-check-label" for="binWeekly">Weekly</label>
      </div>
      <div class="form-check">
        <input class="form-check-input" type="radio" name="binning" id="binMonthly" value="Monthly" />
        <label class="form-check-label" for="binMonthly">Monthly</label>
      </div>
      <div class="form-check">
        <input class="form-check-input" type="radio" name="binning" id="binDaily" value="Daily" checked />
        <label class="form-check-label" for="binDaily">Daily</label>
      </div>
    </div>

    <!-- File Upload & Example Dataset Buttons -->
    <div class="col-md-3">
      <label for="fileUpload" class="form-label"><strong>Load Data:</strong></label>
      <input type="file" id="fileUpload" accept=".csv, .xlsx, .xls" class="form-control mb-2" />
      <button id="loadDefaultBtn" class="btn btn-secondary btn-sm mb-1"
        data-bs-toggle="popover"
        data-bs-trigger="hover focus"
        data-bs-placement="top"
        data-bs-content="Real Seizure diary data from FLE patient with frequent focal seizures.">
        Default Data
      </button>
      
      
      <button id="loadExample1Btn" class="btn btn-secondary btn-sm mb-1"
      data-bs-toggle="popover"
      data-bs-trigger="hover focus"
      data-bs-placement="top"
      data-bs-content="Simulated seizure diary, showing slight pre-menstural increase in seizure likelihood.">
      Example 1
    </button>
      <button id="loadExample2Btn" class="btn btn-secondary btn-sm mb-1"
      data-bs-toggle="popover"
      data-bs-trigger="hover focus"
      data-bs-placement="top"
      data-bs-content="Simulated seizure diary, seizure clusters tending to occur in summer.">
      Example 2
    </button>
      <button id="downloadTemplateBtn" class="btn btn-secondary btn-sm mb-1"
        data-bs-toggle="popover"
        data-bs-trigger="hover focus"
        data-bs-placement="bottom"
        data-bs-content="Download an Excel template that includes three columns: Action, UTC date, and Note. Fill in your diary details and then upload the file using the Load Data function.">
        Download Template Excel
      </button>
    </div>
  </div>

  <!-- Row: Analysis Range -->
  <div class="row mb-4">
    <div class="col-auto">
      <label class="form-label"><strong>Analysis Range from Heatmap selection</strong></label>
      <select id="analysisRange" class="form-select" style="width: 220px;">
        <option value="month" selected>Full Month</option>
        <option value="2weeks">2 Weeks</option>
        <option value="2months">2 Months</option>
        <option value="6months">6 Months</option>
        <option value="same">Same as Heatmap Binning</option>
      </select>
    </div>
  </div>

  <!-- Row: Main Charts -->
  <div class="row">
    <!-- Left Column: Bar Chart + Heatmap + Medication Graph -->
    <div class="col-md-7">
      <div class="chart-container">
        <div class="chart-title">Seizure Counts Over Time</div>
        <div id="barChart"></div>
      </div>
      <div class="chart-container">
        <div class="chart-title">
          Heatmap (Hour of Day): Single-click to highlight, double-click to compare
        </div>
        <!-- Toggle button group for heatmap display mode -->
        <div id="heatmapToggleGroup" class="btn-group mb-2" role="group">
          <button type="button" class="btn btn-outline-secondary active" data-mode="count">Count</button>
          <button type="button" class="btn btn-outline-secondary" data-mode="duration">Duration</button>
        </div>
        <div id="heatmap"></div>
      </div>
      <div class="chart-container">
        <div class="chart-title">Drug Dosage Over Time</div>
        <div id="medGraph"></div>
        <div class="btn-group mt-3" role="group" aria-label="Medication toggles" id="medToggleGroup">
          <button type="button" class="btn btn-outline-primary active" data-med="Cenobamate">Cenobamate</button>
          <button type="button" class="btn btn-outline-primary active" data-med="Vimpat">Vimpat</button>
          <button type="button" class="btn btn-outline-primary active" data-med="Perampanel">Perampanel</button>
          <button type="button" class="btn btn-outline-primary active" data-med="Clobazam">Clobazam</button>
        </div>
      </div>
    </div>

    <!-- Right Column: Additional Plots -->
    <div class="col-md-5">
      <!-- Detail Graphs with Tabs -->
      <div class="chart-container">
        <!-- Nav Tabs -->
        <ul class="nav nav-tabs" id="detailTab" role="tablist">
          <li class="nav-item" role="presentation">
            <button class="nav-link active" id="tab1-tab" data-bs-toggle="tab" data-bs-target="#tab1" 
                    type="button" role="tab" aria-controls="tab1" aria-selected="true">
              Detail Graph
            </button>
          </li>
          <li class="nav-item" role="presentation">
            <button class="nav-link" id="tab2-tab" data-bs-toggle="tab" data-bs-target="#tab2" 
                    type="button" role="tab" aria-controls="tab2" aria-selected="false">
              Periodicity
            </button>
          </li>
          <li class="nav-item" role="presentation">
            <button class="nav-link" id="tab3-tab" data-bs-toggle="tab" data-bs-target="#tab3" 
                    type="button" role="tab" aria-controls="tab3" aria-selected="false">
              Event Dependence
            </button>
          </li>
        </ul>
        <!-- Tab Panes -->
        <div class="tab-content" id="detailTabContent">
          <div class="tab-pane fade show active" id="tab1" role="tabpanel" aria-labelledby="tab1-tab">
            <div id="dailyGraph" style="height:500px;"></div>
          </div>
          <div class="tab-pane fade" id="tab2" role="tabpanel" aria-labelledby="tab2-tab">
            <div id="acfGraph" style="height:500px;"></div>
            <div id="tab2" role="tabpanel" aria-labelledby="tab2-tab">
              <div class="mb-3">
                <label for="acfLagSlider" class="form-label">Max Lag (weeks):</label>
                <input type="range" id="acfLagSlider" min="0.1" max="52" step="0.1" value="10">
                <span id="acfLagValue">10</span> weeks
              </div>
              <div id="acfGraph" style="height:500px;"></div>
            </div>


          </div>
          <div class="tab-pane fade" id="tab3" role="tabpanel" aria-labelledby="tab3-tab">
            <!-- Event Dependence Controls -->
            <div class="row mb-3">
              <div class="col-md-6">
                <label for="triggerEvent" class="form-label">Trigger Event</label>
                <select id="triggerEvent" class="form-select">
                  <!-- Options populated dynamically -->
                </select>
              </div>
              <div class="col-md-6">
                <label for="responseEvent" class="form-label">Response Event</label>
                <select id="responseEvent" class="form-select">
                  <!-- Options populated dynamically -->
                </select>
              </div>
            </div>
            <div class="mb-3">
              <label for="lagSlider" class="form-label">Select Lag:</label>
              <input type="range" id="lagSlider" min="1" max="50" value="10" class="form-range">
              <span id="lagValue">10</span>
            </div>
            <div class="chart-container">
              <div class="chart-title">Event Dependence Analysis</div>
              <div id="eventDepGraph" style="height:400px;"></div>
            </div>
          </div>
        </div>
      </div>
      <div class="chart-container">
        <div class="chart-title">Seizure counts over daytime</div>
        <div id="hourlyGraph" style="height:400px;"></div>
      </div>
    </div>
  </div><!-- end row -->

</div> <!-- end container -->

<!-- Bootstrap JS Bundle -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

<!-- Custom Script -->
<script>
// GLOBAL VARIABLES
let globalData = [];
let firstData = null;
let secondData = null;
let xLabels = [];
let shapeList = []; // For heatmap overlays
const defaultFileUrl = "data/When-Did-I_2_ID.xlsx"; // Adjust file path as needed

function processUploadedData(data) {
  console.log(`Processing ${data.length} raw rows from file`);
  
  // Add debug counters
  let rowsWithoutAction = 0;
  let rowsWithInvalidDate = 0;
  let rowsProcessed = 0;
  
  const processed = data
    .map((row, index) => {
      // Check if Action is missing
      if (!row["Action"]) {
        rowsWithoutAction++;
        if (rowsWithoutAction < 10) {
          console.warn(`Row ${index} missing Action:`, row);
        }
        return null;
      }
      
      // Extract date from multiple possible column names
      const rawValue = row["UTC Time"] || row["UTC date"] || row["Date"];
      
      if (!rawValue) {
        rowsWithInvalidDate++;
        if (rowsWithInvalidDate < 10) {
          console.warn(`Row ${index} missing date value:`, row);
        }
        return null;
      }
      
      let dt;
      try {
        // If rawValue is a string that represents a number, convert it
        let dateValue = (typeof rawValue === "string" && /^\d+$/.test(rawValue))
          ? Number(rawValue)
          : rawValue;

        if (typeof dateValue === "number") {
          if (dateValue < 100000) {
            dt = new Date((dateValue - 25569) * 86400000);
          } else {
            dt = new Date(dateValue < 1e11 ? dateValue * 1000 : dateValue);
          }
        } else {
          dt = new Date(dateValue);

          if (isNaN(dt.getTime())) {
            if (/^\d{1,2}\/\d{1,2}\/\d{4}/.test(dateValue)) {
              const [datePart, timePart] = dateValue.split(" ");
              const [day, month, year] = datePart.split("/").map(n => parseInt(n));
              let hour = 0, minute = 0;
              if (timePart && timePart.includes(":")) {
                [hour, minute] = timePart.split(":").map(n => parseInt(n));
              }
              dt = new Date(year, month - 1, day, hour, minute);
            }
            else if (/^\d{4}-\d{1,2}-\d{1,2}/.test(dateValue)) {
              const [year, month, day] = dateValue.split('-').map(n => parseInt(n));
              dt = new Date(year, month - 1, day);
            }
          }
        }
        
        if (isNaN(dt.getTime())) {
          rowsWithInvalidDate++;
          if (rowsWithInvalidDate < 10) {
            console.warn(`Row ${index} has invalid date value:`, rawValue);
          }
          return null;
        }
        
        rowsProcessed++;
        
        // NEW: Extract the duration.
        // Try multiple header names: "Duration", "Seizure Duration", etc.
        let durationStr = row["Duration"] || row["Seizure Duration"] || "";
        let duration = parseFloat(durationStr) || 0;
        
        return {
          datetime: dt,
          action: row["Action"].trim(),
          note: typeof row["Note"] === "string" ? row["Note"].trim() : (row["Note"] ?? "").toString(),
          duration: duration, // New field
          hour: dt.getHours(),
          id: row["ID"] ? row["ID"].trim() : "Unknown"
        };
      } catch (error) {
        console.error(`Error processing row ${index}:`, error, row);
        return null;
      }
    })
    .filter(item => item !== null);
  
  console.log(`
    Data processing summary:
    - Total rows: ${data.length}
    - Rows without Action: ${rowsWithoutAction}
    - Rows with invalid date: ${rowsWithInvalidDate}
    - Successfully processed: ${rowsProcessed}
    - Final data length: ${processed.length}
  `);
  
  return processed;
}


// Improved CSV parsing to handle different CSV formats 
function loadExampleDataset(url) {
  if (url.match(/\.csv$/i)) {
    console.log(`Loading CSV from ${url}`);
    Papa.parse(url, {
      download: true,
      header: true,
      skipEmptyLines: true,
      transformHeader: (header) => {
        // Normalize headers to handle capitalization and spacing differences
        return header.trim();
      },
      complete: function(results) {
  globalData = processUploadedData(results.data);

  if (globalData.length > 0) {
    const sortedDates = globalData
      .map(d => d.datetime)
      .sort((a, b) => a - b);
    const minDate = sortedDates[0];
    const maxDate = sortedDates[sortedDates.length - 1];

    document.getElementById("startDate")._flatpickr.setDate(minDate);
    document.getElementById("endDate")._flatpickr.setDate(maxDate);
  }

  populateSeizureTypes();
  populateMedicationButtons();
  populateUserDropdown();
  updateCharts();
  updateACFGraph()
  console.log(`Loaded CSV dataset from ${url}: ${globalData.length} records`);
}
        
      ,
      error: function(err) {
        console.error("Error loading CSV dataset from", url, ":", err);
      }
    });
  } else if (url.match(/\.(xls|xlsx)$/i)) {
    console.log(`Loading Excel file from ${url}`);
    fetch(url)
      .then(response => response.arrayBuffer())
      .then(arrayBuffer => {
        const data = new Uint8Array(arrayBuffer);
        const workbook = XLSX.read(data, { type: "array" });
        const firstSheetName = workbook.SheetNames[0];
        const worksheet = workbook.Sheets[firstSheetName];
        
        // Log workbook and worksheet information for debugging
        console.log("Workbook sheets:", workbook.SheetNames);
        console.log("First few cells of worksheet:", 
          XLSX.utils.sheet_to_json(worksheet, { header: 1, range: 0, defval: "" }).slice(0, 3));
        
        const jsonData = XLSX.utils.sheet_to_json(worksheet, { 
          defval: "",
          raw: true,      // Keep raw values for better date handling
          dateNF: 'yyyy-mm-dd',  // Format for dates
          header: 1       // Use first row as headers
        });
        
        // Convert the jsonData to have named headers
        const headers = jsonData[0];
        const dataWithHeaders = jsonData.slice(1).map(row => {
          const item = {};
          headers.forEach((header, i) => {
            if (header) item[header.trim()] = row[i];
          });
          return item;
        });
        
        console.log(`Converted Excel with ${dataWithHeaders.length} rows`);
        console.log("Sample of first row:", dataWithHeaders[0]);
        console.log("Available columns:", Object.keys(dataWithHeaders[0]));
        
        globalData = processUploadedData(dataWithHeaders);
        populateSeizureTypes();
        populateMedicationButtons();
        populateUserDropdown();
        updateCharts();
        updateACFGraph()
        console.log(`Loaded Excel dataset from ${url}: ${globalData.length} records`);
      })
      .catch(err => {
        console.error("Error loading Excel dataset from", url, ":", err);
      });
  } else {
    console.error("Unsupported file type for URL:", url);
  }
}

// Enhanced file upload handler with better error handling
function handleFileUpload(evt) {
  console.log("File upload initiated");
  const file = evt.target.files[0];
  if (!file) {
    console.warn("No file selected");
    return;
  }
  
  console.log(`Processing file: ${file.name} (${file.size} bytes, ${file.type})`);
  const fileName = file.name.toLowerCase();
  
  if (fileName.endsWith(".csv")) {
    Papa.parse(file, {
      header: true,
      skipEmptyLines: true,
      transformHeader: (header) => {
        // Normalize headers to handle capitalization and spacing differences
        return header.trim();
      },
      complete: function(results) {
        console.log(`Parsed CSV with ${results.data.length} rows`);
        console.log("CSV parsing errors:", results.errors);
        console.log("Available columns:", results.meta.fields);
        console.log("Sample of first row:", results.data[0]);
        
        globalData = processUploadedData(results.data);
        populateSeizureTypes();
        populateMedicationButtons();
        populateUserDropdown();
        updateCharts();
        updateACFGraph()
        console.log(`Loaded CSV file from user: ${globalData.length} records`);
      },
      error: function(err) {
        console.error("Error parsing CSV:", err);
        alert(`Error parsing CSV: ${err.message}`);
      }
    });
  } else if (fileName.endsWith(".xls") || fileName.endsWith(".xlsx")) {
    const reader = new FileReader();
    reader.onload = function(e) {
      try {
        const data = new Uint8Array(e.target.result);
        const workbook = XLSX.read(data, { 
          type: "array",
          cellDates: true,  // Convert dates to JS Date objects
          dateNF: 'yyyy-mm-dd' // Date format
        });
        
        console.log("Excel workbook loaded with sheets:", workbook.SheetNames);
        
        const firstSheetName = workbook.SheetNames[0];
        const worksheet = workbook.Sheets[firstSheetName];
        
        // Log the first few cells for debugging
        const sample = XLSX.utils.sheet_to_json(worksheet, { 
          header: 1, 
          range: 0,
          defval: ""
        }).slice(0, 3);
        console.log("Sample rows:", sample);
        
        const jsonData = XLSX.utils.sheet_to_json(worksheet, { 
          defval: "",
          raw: true
        });
        
        console.log(`Converted Excel with ${jsonData.length} rows`);
        console.log("Sample of first row:", jsonData[0]);
        console.log("Available columns:", Object.keys(jsonData[0]));
        
        globalData = processUploadedData(jsonData);
        populateSeizureTypes();
        populateMedicationButtons();
        populateUserDropdown();
        updateCharts();
        updateACFGraph()
        console.log(`Loaded Excel file from user: ${globalData.length} records`);
      } catch (error) {
        console.error("Error processing Excel file:", error);
        alert(`Error processing Excel file: ${error.message}`);
      }
    };
    reader.onerror = function(e) {
      console.error("Error reading Excel file:", e);
      alert("Error reading the file. Please try again with a different file.");
    };
    reader.readAsArrayBuffer(file);
  } else {
    alert("Unsupported file type. Please upload a CSV or Excel file.");
  }
}



function getMedicationName(actionText) {
  actionText = actionText.toLowerCase();
  for (const med in medSynonyms) {
    for (const synonym of medSynonyms[med]) {
      if (actionText.indexOf(synonym.toLowerCase()) !== -1) {
        //console.log(`Found "${synonym}" in "${actionText}" => ${med}`);
        return med; // returns the canonical name (e.g. "Cenobamate")
      }
    }
  }
  return null;
}

function populateMedicationButtons() {
  const medToggleGroup = document.getElementById("medToggleGroup");
  medToggleGroup.innerHTML = ""; // clear existing buttons

  // Use a Set to gather unique medication names from globalData.
  let medsFound = new Set();
  globalData.forEach(row => {
    let medName = getMedicationName(row.action);
    if (medName) {
      medsFound.add(medName);
    }
  });

  // If no medications found, you might add a default message.
  if (medsFound.size === 0) {
    medToggleGroup.innerHTML = "<p>No medication events found.</p>";
    return;
  }

  // Create a button for each medication.
  medsFound.forEach(med => {
    let btn = document.createElement("button");
    btn.type = "button";
    btn.className = "btn btn-outline-primary btn-sm m-1 active";
    // Use a data attribute to store the canonical med name.
    btn.setAttribute("data-med", med);
    btn.textContent = med;
    medToggleGroup.appendChild(btn);
  });
  
  // Reinitialize event listeners on the newly created buttons.
  initMedToggleButtons();
}

function loadExampleDataset(url) {
  if (url.match(/\.csv$/i)) {
    Papa.parse(url, {
      download: true,
      header: true,
      skipEmptyLines: true,
      complete: function(results) {
        // Only the needed columns are picked by processUploadedData.
        globalData = processUploadedData(results.data);
        updateCharts();
        updateACFGraph()
        populateSeizureTypes();
        populateMedicationButtons();
        populateUserDropdown(); // Populate the user dropdown
        console.log("Loaded CSV dataset from:", url);
      },
      error: function(err) {
        console.error("Error loading CSV dataset from", url, ":", err);
      }
    });
  } else if (url.match(/\.(xls|xlsx)$/i)) {
    fetch(url)
      .then(response => response.arrayBuffer())
      .then(arrayBuffer => {
        const data = new Uint8Array(arrayBuffer);
        const workbook = XLSX.read(data, { type: "array" });
        const firstSheetName = workbook.SheetNames[0];
        const worksheet = workbook.Sheets[firstSheetName];
        const jsonData = XLSX.utils.sheet_to_json(worksheet, { defval: "" });
        // Process the data using our updated function
        globalData = processUploadedData(jsonData);
        updateCharts();
        updateACFGraph()
        populateSeizureTypes();
        populateMedicationButtons();
        populateUserDropdown(); // Populate the user dropdown
        console.log("Loaded Excel dataset from:", url);
      })
      .catch(err => {
        console.error("Error loading Excel dataset from", url, ":", err);
      });
  } else {
    console.error("Unsupported file type for URL:", url);
  }
}

function handleFileUpload(evt) {
  const file = evt.target.files[0];
  if (!file) return;
  const fileName = file.name.toLowerCase();
  if (fileName.endsWith(".csv")) {
    Papa.parse(file, {
      header: true,
      skipEmptyLines: true,
      complete: function(results) {
        globalData = processUploadedData(results.data);
        populateSeizureTypes(); // Update dropdown
        populateMedicationButtons();
        populateUserDropdown(); // Populate the user dropdown
        updateCharts();
        updateACFGraph()
        
        console.log("Loaded CSV file from user.");
      },
      error: function(err) {
        console.error("Error parsing CSV:", err);
      }
    });
  } else if (fileName.endsWith(".xls") || fileName.endsWith(".xlsx")) {
    const reader = new FileReader();
    reader.onload = function(e) {
      const data = new Uint8Array(e.target.result);
      const workbook = XLSX.read(data, { type: "array" });
      const firstSheetName = workbook.SheetNames[0];
      const worksheet = workbook.Sheets[firstSheetName];
      const jsonData = XLSX.utils.sheet_to_json(worksheet, { defval: "" });
      
      globalData = processUploadedData(jsonData);
      populateMedicationButtons();
      populateSeizureTypes(); // Update dropdown
      populateUserDropdown(); // Populate the user dropdown
      updateCharts();
      updateACFGraph()
      console.log("Loaded Excel file from user.");
    };
    reader.onerror = function(e) {
      console.error("Error reading Excel file:", e);
    };
    reader.readAsArrayBuffer(file);
  } else {
    alert("Unsupported file type. Please upload a CSV or Excel file.");
  }
}

// UTILITY: Format date for input
function formatDateInput(d) {
  let yyyy = d.getFullYear();
  let mm = String(d.getMonth() + 1).padStart(2, "0");
  let dd = String(d.getDate()).padStart(2, "0");
  return `${yyyy}-${mm}-${dd}`;
}

function runEventDependenceAnalysis() {
  const anchor = document.getElementById("triggerEvent").value;
  const response = document.getElementById("responseEvent").value;
  const maxLag = parseInt(document.getElementById("lagSlider").value, 10);

  // Get all anchor events
  let anchorEvents = globalData.filter(e => e.action === anchor);

  // Prepare bins for lags from -maxLag..+maxLag
  let lagBins = [];
  let counts = [];  // Will store how many anchor events had a response at this lag
  for (let lag = -maxLag; lag <= maxLag; lag++) {
    lagBins.push(lag);
    counts.push(0);
  }

  // For each anchor event, figure out which lags have at least one response event
  anchorEvents.forEach(anchorEvent => {
    // We'll track which lags are "hit" by at least one response
    // so we only increment once per anchor event per lag.
    let hits = new Set();

    // Check all response events
    globalData.filter(e => e.action === response).forEach(responseEvent => {
      let lagDays = Math.round((responseEvent.datetime - anchorEvent.datetime) / (86400000)); 
      // If lagDays is in range, mark it as a "hit"
      if (lagDays >= -maxLag && lagDays <= maxLag) {
        hits.add(lagDays);
      }
    });
console.log(globalData)
    // Now increment the count for each lag that got a hit
    hits.forEach(l => {
      counts[l + maxLag] += 1; 
    });
  });

  // Convert counts to probability: fraction of anchor events that had a response
  if (anchorEvents.length > 0) {
    for (let i = 0; i < counts.length; i++) {
      counts[i] = counts[i] / anchorEvents.length;
    }
  }

  // Plot the results
  let trace = {
    x: lagBins,
    y: counts,
    mode: 'lines+markers',
    type: 'scatter',
    name: 'Probability'
  };
  let layout = {
    title: `P("${response}" | ${anchor}, day lag)`,
    xaxis: { title: "Lag (days)" },
    yaxis: { title: "Probability (0..1)" }
  };
  Plotly.newPlot("eventDepGraph", [trace], layout);
}

/**
 * Helper function for monthly binning.
 * Expects format "YYYY-MM" (e.g. "2024-11") and returns a Date object for the 1st of that month.
 */
 function parseYearMonth(ymStr) {
  const parts = ymStr.split("-");
  if (parts.length < 2) return null;
  const year = parseInt(parts[0], 10);
  const month = parseInt(parts[1], 10) - 1;
  return new Date(year, month, 1);
}

function populateEventDropdowns() {
  // Get all unique actions from globalData
  const actions = [...new Set(globalData.map(row => row.action))];
  const triggerDropdown = document.getElementById("triggerEvent");
  const responseDropdown = document.getElementById("responseEvent");

  // Clear any existing options
  triggerDropdown.innerHTML = "";
  responseDropdown.innerHTML = "";

  // Create a default option
  let defaultOption = document.createElement("option");
  defaultOption.textContent = "-- Select an event --";
  defaultOption.value = "";
  triggerDropdown.appendChild(defaultOption.cloneNode(true));
  responseDropdown.appendChild(defaultOption.cloneNode(true));

  // Populate dropdowns with each action
  actions.forEach(action => {
    let option1 = document.createElement("option");
    option1.textContent = action;
    option1.value = action;
    triggerDropdown.appendChild(option1);

    let option2 = document.createElement("option");
    option2.textContent = action;
    option2.value = action;
    responseDropdown.appendChild(option2);
  });
}

// Function to populate the "Seizures to Display" dropdown dynamically.
function populateSeizureTypes() {
  const dropdown = document.getElementById("seizureTypes");
  dropdown.innerHTML = "";
  // Get unique actions from globalData
  let actions = [...new Set(globalData.map(row => row.action))];
  // Optionally, prioritize actions that contain keywords (e.g., "seizure", "tonic clonic")
  const priorityKeywords = ["seizure", "tonic clonic"];
  let prioritized = [];
  let others = [];
  actions.forEach(action => {
    if (priorityKeywords.some(kw => action.toLowerCase().includes(kw))) {
      prioritized.push(action);
    } else {
      others.push(action);
    }
  });
  prioritized.sort();
  others.sort();
  let sortedActions = prioritized.concat(others);
  // Add each option; automatically select the first two options if available
  sortedActions.forEach((action, index) => {
    let option = document.createElement("option");
    option.value = action;
    option.textContent = action;
    if (index < 2) {
      option.selected = true;
    }
    dropdown.appendChild(option);
  });
  //console.log("Seizures to Display updated:", sortedActions);
  updateCharts() 
  updateACFGraph()
}
const medSynonyms = {
  "Carbamazepine": ["tegretol", "carbamazepine"],
  "Lacosamide": ["vimpat", "lacosamide","Vimpat"],
  "Cenobamate": ["ontozry","xcopri","cenobamate","change cenobamate"],
  "Clobazam": ["frisium","onfi","clobazam","change clobazam"],
  "Lamotrogine": ["lamotrigine","Lamictal","Reduce my lamotrogine last"],
  "Keppra": ["levetiracetam","Keppra"],
  "Perampanel": ["perampanel","fycompa"],
  "Midazolam": ["epistatus","midazolam","Need Rescue meds"],
  "IV injected": ["IV Injection","IV injected"]
};

// CHART UPDATE FUNCTIONS
function updateCharts() {
  // 1) Gather user input
  let startVal = document.getElementById("startDate").value;
  let endVal = document.getElementById("endDate").value;
  let startDate = new Date(startVal);
  let endDate = new Date(endVal);
  let stSelect = document.getElementById("seizureTypes");
  let seizureTypes = Array.from(stSelect.selectedOptions).map(o => o.value);
  let binning = document.querySelector("input[name='binning']:checked").value;
  
  // Get selected user ID
  let selectedUserId = document.getElementById("userSelect").value;

  // 2) Filter raw data
  let filtered = globalData.filter(d => {
    let dateInRange = d.datetime >= startDate && d.datetime <= endDate;
    let actionMatches = seizureTypes.includes(d.action);
    let userMatches = selectedUserId === "all" || d.id === selectedUserId;
    
    return dateInRange && actionMatches && userMatches;
  });

// 3) Build bins based on binning
  let allBins = [];
  if (binning === "Daily") {
    allBins = buildAllDailyBins(startDate, endDate);
  } else if (binning === "Weekly") {
    allBins = buildAllWeeklyBins(startDate, endDate);
  } else if (binning === "Monthly") {
    allBins = buildAllMonthlyBins(startDate, endDate);
  }
  xLabels = allBins;

   // 4) Group filtered data by period
   let grouped = groupByPeriod(filtered, binning);

  // 5) Create bar chart
  //let yCounts = allBins.map(binLabel => (grouped[binLabel] ? grouped[binLabel].length : 0));
  //let barTrace = { x: xLabels, y: yCounts, type: "bar", name: "Seizure Counts" };
  //let barLayout = { margin: { t: 10, b: 30 }, height: 180, yaxis: { title: "Seizure Count" } };
  //Plotly.newPlot("barChart", [barTrace], barLayout);
    let yData;
    let yAxisTitle;
    if (heatmapMode === "duration") {
      // Calculate the average seizure duration for each bin
      yData = allBins.map(binLabel => {
        let events = grouped[binLabel] || [];
        if (events.length > 0) {
          let totalDuration = events.reduce((sum, event) => sum + event.duration, 0);
          return totalDuration / events.length;
        } else {
          return 0;
        }
      });
      yAxisTitle = "Avg. Seizure Duration";
    } else {
      // Default mode: count the number of seizures in each bin
      yData = allBins.map(binLabel => (grouped[binLabel] ? grouped[binLabel].length : 0));
      yAxisTitle = "Seizure Count";
    }

    let barTrace = { x: xLabels, y: yData, type: "bar", name: yAxisTitle };
    let barLayout = { margin: { t: 10, b: 30 }, height: 180, yaxis: { title: yAxisTitle } };
    Plotly.newPlot("barChart", [barTrace], barLayout);


  // 6) Build heatmap matrix
// Build heatmap matrix using either count or total duration per hour.
let periodHourValues = allBins.map(label => {
  let arr24 = new Array(24).fill(0);
  if (grouped[label]) {
    grouped[label].forEach(item => {
      if (heatmapMode === "duration") {
        arr24[item.hour] += parseFloat(item.duration) || 0;

      } else {
        arr24[item.hour]++; // Count events
      }
    });
  }
  return arr24;
});

  let heatmapMatrix = [];
  for (let hour = 0; hour < 24; hour++) {
    let row = [];
    for (let col = 0; col < allBins.length; col++) {
      row.push(periodHourValues[col][hour]);
    }
    heatmapMatrix.push(row);
    //console.log("Duration value:", row["Duration"], typeof row["Duration"]);

  }
  heatmapMatrix.reverse();
  let heatmapTrace = {
    z: heatmapMatrix,
    x: xLabels,
    y: [...Array(24).keys()].reverse(),
    type: "heatmap",
    colorscale: "Viridis"
  };
  let heatmapLayout = {
    margin: { t: 20, b: 20 },
    height: 600,
    xaxis: { title: "Time Period", type: "category" },
    yaxis: { title: "Hour of Day" }
  };
  Plotly.newPlot("heatmap", [heatmapTrace], heatmapLayout).then(plot => {
    let lastClickTime = 0;
    let clickDelay = 300;
    let clickTimeout = null;
    plot.on("plotly_click", data => {
      if (!data.points || !data.points[0]) return;
      let clickedLabel = data.points[0].x;
      let now = Date.now();
      if (now - lastClickTime < clickDelay) {
        clearTimeout(clickTimeout);
        lastClickTime = 0;
        handleDoubleClick(clickedLabel);
      } else {
        lastClickTime = now;
        clickTimeout = setTimeout(() => {
          handleSingleClick(clickedLabel);
        }, clickDelay);
      }
    });
  });

 // Update the title to include user info if a specific user is selected
 if (selectedUserId !== "all") {
    document.querySelector("h1").textContent = `Interactive Epilepsy Seizure Diary Data Dashboard - User ${selectedUserId}`;
  } else {
    document.querySelector("h1").textContent = "Interactive Epilepsy Seizure Diary Data Dashboard";
  }

  updateMedGraph();
  populateEventDropdowns();
  updateDetailGraphs(null, null);
}

function buildAllDailyBins(startDate, endDate) {
  let bins = [];
  let cur = new Date(startDate);
  cur.setHours(0, 0, 0, 0);
  while (cur <= endDate) {
    bins.push(formatYYYYMMDD(cur));
    cur.setDate(cur.getDate() + 1);
  }
  return bins;
}

function formatYYYYMMDD(d) {
  const yyyy = d.getFullYear();
  const mm = String(d.getMonth() + 1).padStart(2, "0");
  const dd = String(d.getDate()).padStart(2, "0");
  return `${yyyy}-${mm}-${dd}`;
}

function buildAllWeeklyBins(startDate, endDate) {
  let bins = [];
  let cur = findWeekStart(startDate);
  while (cur <= endDate) {
    bins.push(formatISOWeek(cur));
    cur.setDate(cur.getDate() + 7);
  }
  return bins;
}

function findWeekStart(date) {
  let d = new Date(date);
  let day = d.getDay();
  let diff = (day + 6) % 7;
  d.setDate(d.getDate() - diff);
  d.setHours(0, 0, 0, 0);
  return d;
}

function formatISOWeek(date) {
  const year = date.getFullYear();
  let jan1 = new Date(year, 0, 1);
  let dayOfYear = Math.floor((date - jan1) / 86400000) + 1;
  let week = Math.ceil(dayOfYear / 7);
  return `${year}-W${String(week).padStart(2, "0")}`;
}

function buildAllMonthlyBins(startDate, endDate) {
  let bins = [];
  let y = startDate.getFullYear();
  let m = startDate.getMonth();
  let endY = endDate.getFullYear();
  let endM = endDate.getMonth();
  while (y < endY || (y === endY && m <= endM)) {
    bins.push(`${y}-${String(m + 1).padStart(2, "0")}`);
    m++;
    if (m > 11) { m = 0; y++; }
  }
  return bins;
}

function groupByPeriod(data, freq) {
  let groups = {};
  data.forEach(item => {
    let label = "";
    let dt = item.datetime;
    if (freq === "Daily") {
      label = dt.toISOString().slice(0, 10);
    } else if (freq === "Weekly") {
      let year = dt.getFullYear();
      let oneJan = new Date(year, 0, 1);
      let dayOfYear = ((dt - oneJan) / 86400000) + 1;
      let week = Math.ceil(dayOfYear / 7);
      label = `${year}-W${String(week).padStart(2, "0")}`;
    } else if (freq === "Monthly") {
      let year = dt.getFullYear();
      let month = String(dt.getMonth() + 1).padStart(2, "0");
      label = `${year}-${month}`;
    } else {
      label = "Unknown";
    }
    if (!groups[label]) { groups[label] = []; }
    groups[label].push(item);
  });
  return groups;
}

function handleSingleClick(label) {
  //console.log("Single click on", label);
  let newDataset = buildAnalysisSubset(label);
  if (!newDataset) return;
  firstData = newDataset;
  secondData = null;
  clearOverlays();
  let freq = document.querySelector("input[name='binning']:checked").value;
  let startLabel, endLabel;
  if (freq === "Daily") {
    startLabel = new Date(newDataset.min_date).toISOString().slice(0, 10);
    endLabel = new Date(newDataset.max_date).toISOString().slice(0, 10);
  } else if (freq === "Weekly") {
    startLabel = formatISOWeek(new Date(newDataset.min_date));
    endLabel = formatISOWeek(new Date(newDataset.max_date));
  } else if (freq === "Monthly") {
    let st = new Date(newDataset.min_date);
    let en = new Date(newDataset.max_date);
    startLabel = `${st.getFullYear()}-${String(st.getMonth()+1).padStart(2, "0")}`;
    endLabel = `${en.getFullYear()}-${String(en.getMonth()+1).padStart(2, "0")}`;
  }
  addShapeForRange(startLabel, endLabel, "blue", 0.3);
  updateDetailGraphs(firstData, secondData);
}

function handleDoubleClick(label) {
  //console.log("Double click on", label);
  let newDataset = buildAnalysisSubset(label);
  if (!newDataset) return;
  if (!firstData) {
    firstData = newDataset;
  } else {
    secondData = newDataset;
  }
  let freq = document.querySelector("input[name='binning']:checked").value;
  let startLabel, endLabel;
  if (freq === "Daily") {
    startLabel = new Date(newDataset.min_date).toISOString().slice(0, 10);
    endLabel = new Date(newDataset.max_date).toISOString().slice(0, 10);
  } else if (freq === "Weekly") {
    startLabel = formatISOWeek(new Date(newDataset.min_date));
    endLabel = formatISOWeek(new Date(newDataset.max_date));
  } else if (freq === "Monthly") {
    let st = new Date(newDataset.min_date);
    let en = new Date(newDataset.max_date);
    startLabel = `${st.getFullYear()}-${String(st.getMonth()+1).padStart(2, "0")}`;
    endLabel = `${en.getFullYear()}-${String(en.getMonth()+1).padStart(2, "0")}`;
  }
  removeShapeByColor("red");
  addShapeForRange(startLabel, endLabel, "red", 0.3);
  updateDetailGraphs(firstData, secondData);
}

function buildAnalysisSubset(clickedLabel) {
  let freq = document.querySelector("input[name='binning']:checked").value;
  let [startTime, endTime] = getPeriodDateRange(clickedLabel, freq);
  if (!startTime || !endTime) {
    console.warn("Could not parse period:", clickedLabel);
    return null;
  }
  let analysis = document.getElementById("analysisRange").value;
  if (analysis === "month") {
    let monthStart = new Date(startTime.getFullYear(), startTime.getMonth(), 1);
    let nextMonth = new Date(monthStart.getFullYear(), monthStart.getMonth() + 1, 1);
    let monthEnd = new Date(nextMonth - 1);
    startTime = monthStart;
    endTime = monthEnd;
  } else if (analysis === "2weeks") {
    let plus14 = new Date(startTime.getTime() + 14 * 86400000 - 1);
    endTime = plus14;
  } else if (analysis === "2months") {
    let twoMonthsLater = new Date(startTime);
    twoMonthsLater.setMonth(twoMonthsLater.getMonth() + 2);
    twoMonthsLater.setMilliseconds(twoMonthsLater.getMilliseconds() - 1);
    endTime = twoMonthsLater;
  } else if (analysis === "6months") {
    let sixMonthsLater = new Date(startTime);
    sixMonthsLater.setMonth(sixMonthsLater.getMonth() + 6);
    sixMonthsLater.setMilliseconds(sixMonthsLater.getMilliseconds() - 1);
    endTime = sixMonthsLater;
  }
  let subset = globalData.filter(d => d.datetime >= startTime && d.datetime <= endTime);
  return buildDetailDataset(subset, clickedLabel + " (" + analysis + ")", startTime, endTime);
}

function getPeriodDateRange(periodStr, freq) {
  if (!periodStr) return [null, null];
  if (freq === "Daily") {
    let start = new Date(periodStr);
    let end = new Date(start);
    end.setDate(end.getDate() + 1);
    end.setMilliseconds(end.getMilliseconds() - 1);
    return [start, end];
  } else if (freq === "Weekly") {
    let match = periodStr.match(/^(\d{4})-W(\d{2})$/);
    if (!match) return [null, null];
    let year = parseInt(match[1], 10);
    let w = parseInt(match[2], 10);
    let jan1 = new Date(year, 0, 1);
    let start = new Date(jan1.getTime() + (w - 1) * 7 * 86400000);
    while (start.getDay() !== 1) { start.setDate(start.getDate() - 1); }
    let end = new Date(start.getTime() + 7 * 86400000 - 1);
    return [start, end];
  } else if (freq === "Monthly") {
    let parts = periodStr.split("-");
    if (parts.length < 2) return [null, null];
    let year = parseInt(parts[0], 10);
    let month = parseInt(parts[1], 10) - 1;
    let start = new Date(year, month, 1);
    let end = new Date(year, month + 1, 1);
    end = new Date(end - 1);
    return [start, end];
  }
  return [null, null];
}

function buildDetailDataset(subset, label, startTime, endTime) {
  let dailyMap = {};
  let dayCount = 0;
  if (subset.length > 0) {
    let minDay = new Date(subset[0].datetime);
    let maxDay = new Date(subset[0].datetime);
    subset.forEach(d => {
      if (d.datetime < minDay) minDay = d.datetime;
      if (d.datetime > maxDay) maxDay = d.datetime;
    });
    let dayStart = new Date(minDay);
    dayStart.setHours(0, 0, 0, 0);
    let dayEnd = new Date(maxDay);
    dayEnd.setHours(0, 0, 0, 0);
    let cur = new Date(dayStart);
    while (cur <= dayEnd) {
      dailyMap[cur.toISOString().slice(0, 10)] = 0;
      cur.setDate(cur.getDate() + 1);
    }
    subset.forEach(d => {
      let dayStr = new Date(d.datetime).toISOString().slice(0, 10);
      dailyMap[dayStr]++;
    });
    dayCount = Object.keys(dailyMap).length;
  }
  let dailyCounts = Object.values(dailyMap);
  let hourSamples = subset.map(d => d.hour);
  return {
    period_str: label,
    daily_counts: dailyCounts,
    day_count: dayCount,
    hour_samples: hourSamples,
    min_date: startTime.toISOString(),
    max_date: endTime.toISOString()
  };
}

function clearOverlays() {
  shapeList = [];
  Plotly.relayout("heatmap", { shapes: [] });
}

function addShapeForRange(startLabel, endLabel, color, opacity) {
  let startIndex = xLabels.indexOf(startLabel);
  let endIndex = xLabels.indexOf(endLabel);
  if (startIndex === -1 || endIndex === -1) {
    console.warn("Overlay range labels not found:", startLabel, endLabel);
    return;
  }
  let newShape = {
    type: "rect",
    xref: "x",
    yref: "y",
    x0: startIndex - 0.5,
    x1: endIndex + 0.5,
    y0: -0.5,
    y1: 23.5,
    fillcolor: color,
    opacity: opacity,
    line: { width: 0 },
    layer: "above"
  };
  shapeList.push(newShape);
  Plotly.relayout("heatmap", { shapes: shapeList });
}

// Define updateMedGraph so it exists
function updateMedGraph() {
  // Get the medications selected via the toggle buttons.
  let medButtons = document.querySelectorAll("#medToggleGroup button");
  let selectedMeds = [];
  medButtons.forEach(btn => {
    if (btn.classList.contains("active")) {
      selectedMeds.push(btn.getAttribute("data-med")); // These should be canonical names
    }
  });

  let traces = [];
  selectedMeds.forEach(med => {
    // Filter events using getMedicationName (which returns the canonical med name)
    let medEvents = globalData.filter(e => getMedicationName(e.action) === med);
    console.log(`Med events for ${med}:`, medEvents.length);
    
    // Extract dose from the Note field for each event.
    let medData = medEvents.map(e => {
      let dose = parseDose(e.note);
      return { datetime: e.datetime, dose: dose };
    }).filter(item => item.dose !== null);
    
    // Sort the events by datetime.
    medData.sort((a, b) => a.datetime - b.datetime);
    let middose=10;
    // For rescue medication "Midazolam", plot as discrete scatter points.
    if (med === "need rescue meds") {
      //console.log("Midazollam")
      let trace = {
        x: medData.map(item => item.datetime),
        y: medData.map(item => middose),
        mode: "markers",
        type: "scatter",
        name: med,
        marker: { size: 15, color: "purple" }
      };
      traces.push(trace);
    } else {
      // For continuous medications, build a step function plot.
      let stepX = [];
      let stepY = [];
      if (medData.length > 0) {
        // Start with the first event.
        stepX.push(medData[0].datetime);
        stepY.push(medData[0].dose);
        for (let i = 1; i < medData.length; i++) {
          let prev = medData[i - 1];
          let curr = medData[i];
          // Hold the previous dose until the current event.
          stepX.push(curr.datetime);
          stepY.push(prev.dose);
          // Then switch to the current dose.
          stepX.push(curr.datetime);
          stepY.push(curr.dose);
        }
        // Extend the last dose until now.
        let now = new Date();
        if (now > medData[medData.length - 1].datetime) {
          stepX.push(now);
          stepY.push(medData[medData.length - 1].dose);
        }
      }
      let trace = {
        x: stepX,
        y: stepY,
        mode: "lines",
        type: "scatter",
        name: med,
        line: { shape: "hv" }
      };
      traces.push(trace);
    }
  });

  // Determine x-axis range from global xLabels.
  let freq = document.querySelector("input[name='binning']:checked").value;
  let xMin, xMax;
  if (freq === "Daily") {
    xMin = new Date(xLabels[0]);
    xMax = new Date(xLabels[xLabels.length - 1]);
  } else if (freq === "Weekly") {
    xMin = parseISOWeek(xLabels[0]);
    xMax = parseISOWeek(xLabels[xLabels.length - 1]);
  } else if (freq === "Monthly") {
    xMin = parseYearMonth(xLabels[0]);
    xMax = parseYearMonth(xLabels[xLabels.length - 1]);
  }
  //console.log("xMin:", xMin, "xMax:", xMax);

  let layout = {
    title: "Medication Dose Over Time",
    xaxis: { title: "Date", type: "date", range: [xMin, xMax] },
    yaxis: { title: "Dose (mg)" },
    height: 400
  };

  Plotly.newPlot("medGraph", traces, layout);
}

function parseDose(note) {
  let match = note.match(/(\d+(\.\d+)?)/);
  return match ? parseFloat(match[1]) : null;
}

function initMedToggleButtons() {
  let medButtons = document.querySelectorAll("#medToggleGroup button");
  medButtons.forEach(btn => {
    btn.addEventListener("click", function () {
      this.classList.toggle("active");
      updateMedGraph();
    });
  });
}

function updateDetailGraphs(d1, d2) {
  // Determine whether to show legends based on window width.
  const isMobile = window.innerWidth < 768;
  let legendSetting = { visible: !isMobile };

  let dailyDiv = document.getElementById("dailyGraph");
  if (!d1) {
    Plotly.newPlot(dailyDiv, [], { title: "No data selected yet.", legend: legendSetting });
    Plotly.newPlot("hourlyGraph", [], { title: "No data selected yet.", legend: legendSetting });
    return;
  }
  if (!d2) {
    let x1 = d1.daily_counts.map((_, i) => i);
    let dailyTrace1 = {
      x: x1,
      y: d1.daily_counts,
      type: "bar",
      name: d1.period_str,
      marker: { color: "blue" }
    };
    Plotly.newPlot(dailyDiv, [dailyTrace1], {
      xaxis: { title: "Day Index" },
      yaxis: { title: "Count" },
      legend: legendSetting
    });
    plotHourlyKDE(d1.hour_samples, "blue", d1.period_str, "hourlyGraph");
  } else {
    let maxLen = Math.max(d1.daily_counts.length, d2.daily_counts.length);
    let d1Padded = d1.daily_counts.concat(Array(maxLen - d1.daily_counts.length).fill(0));
    let d2Padded = d2.daily_counts.concat(Array(maxLen - d2.daily_counts.length).fill(0));
    let xRange = [...Array(maxLen).keys()];
    let dailyTrace1 = {
      x: xRange,
      y: d1Padded,
      type: "bar",
      name: d1.period_str,
      marker: { color: "blue" }
    };
    let dailyTrace2 = {
      x: xRange,
      y: d2Padded,
      type: "bar",
      name: d2.period_str,
      marker: { color: "red" }
    };
    Plotly.newPlot(dailyDiv, [dailyTrace1, dailyTrace2], {
      title: "Daily Seizure Counts (Comparison)",
      xaxis: { title: "Day Index" },
      yaxis: { title: "Count" },
      barmode: "group",
      legend: legendSetting
    });
    plotHourlyKDEComparison(d1.hour_samples, d2.hour_samples, d1.period_str, d2.period_str, "hourlyGraph");
  }
}

function plotHourlyKDE(hourSamples, color, label, divId) {
  let div = document.getElementById(divId);
  if (!hourSamples || hourSamples.length < 2) {
    let trace = {
      x: hourSamples,
      y: hourSamples.map(() => 0.05),
      mode: "markers",
      marker: { color: color },
      name: label
    };
    Plotly.newPlot(div, [trace], {
      title: "Hourly Distribution",
      xaxis: { title: "Hour of Day (0-24)", range: [0, 24], autorange: false },
      yaxis: { title: "Count / Density" }
    });
    return;
  }
  let trace = {
    x: hourSamples,
    type: "histogram",
    name: label,
    marker: { color: color, opacity: 0.6 },
    autobinx: false,
    xbins: { start: 0, end: 24, size: 1 }
  };
  Plotly.newPlot(div, [trace], {
    title: "Hourly Distribution",
    xaxis: { title: "Hour of Day (0-24)", range: [0, 24], autorange: false },
    yaxis: { title: "Count" }
  });
}

function plotHourlyKDEComparison(h1, h2, label1, label2, divId) {
  let div = document.getElementById(divId);
  if (h1.length < 2 && h2.length < 2) {
    Plotly.newPlot(div, [], { title: "Not enough data for both sets." });
    return;
  }
  let trace1 = {
    x: h1,
    type: "histogram",
    name: label1,
    marker: { color: "blue", opacity: 0.5 },
    autobinx: false,
    xbins: { start: 0, end: 24, size: 1 }
  };
  let trace2 = {
    x: h2,
    type: "histogram",
    name: label2,
    marker: { color: "red", opacity: 0.5 },
    autobinx: false,
    xbins: { start: 0, end: 24, size: 1 }
  };
  Plotly.newPlot(div, [trace1, trace2], {
    title: "Hourly Distribution (Comparison)",
    xaxis: { title: "Hour of Day (0-24)", range: [0, 24], autorange: false },
    yaxis: { title: "Count" },
    barmode: "overlay"
  });
}

function removeShapeByColor(color) {
  shapeList = shapeList.filter(s => s.fillcolor !== color);
  Plotly.relayout("heatmap", { shapes: shapeList });
}

// medMapping: Maps button text to action strings in the data.
// const medMapping = {
//   "Cenobamate": "Change Cenobamate",
//   "Vimpat": "Change Vimpat dose",
//   "Perampanel": "Change Perampanel",
//   "Clobazam": "Reduce Clobazam",
//   "Lamotrigine": "Reduce my lamotrogine last"
// };

function initMedToggleButtons() {
  let medButtons = document.querySelectorAll("#medToggleGroup button");
  medButtons.forEach(btn => {
    btn.addEventListener("click", function () {
      this.classList.toggle("active");
      // Log the current active meds:
      let selectedMeds = [];
      medButtons.forEach(b => {
        if(b.classList.contains("active")){
          selectedMeds.push(b.getAttribute("data-med"));
        }
      });
      //console.log("Active medications:", selectedMeds);
      updateMedGraph();
    });
  });
}

function parseISOWeek(weekStr) {
  const match = weekStr.match(/^(\d{4})-W(\d{1,2})$/);
  if (!match) return null;
  const year = parseInt(match[1], 10);
  const week = parseInt(match[2], 10);
  // ISO week: January 4th is always in week 1.
  const jan4 = new Date(year, 0, 4);
  const jan4Day = jan4.getDay(); // 0=Sunday, 1=Monday, etc.
  const mondayOffset = (jan4Day === 0 ? -6 : 1 - jan4Day);
  const firstMonday = new Date(year, 0, 4 + mondayOffset);
  return new Date(firstMonday.getTime() + (week - 1) * 7 * 86400000);
}


function updateMedGraph() {
  let medButtons = document.querySelectorAll("#medToggleGroup button");
  let selectedMeds = [];
  medButtons.forEach(btn => {
    if (btn.classList.contains("active")) {
      selectedMeds.push(btn.getAttribute("data-med")); // These should be the canonical names
    }
  });
  
  let traces = [];
  selectedMeds.forEach(med => {
    let medEvents = globalData.filter(e => getMedicationName(e.action) === med);
    //console.log(`Med events for ${med}:`, medEvents.length);
    let medData = medEvents.map(e => {
      let dose = parseDose(e.note);
      return { datetime: e.datetime, dose: dose };
    }).filter(item => item.dose !== null);
    
    medData.sort((a, b) => a.datetime - b.datetime);
    let stepX = [];
    let stepY = [];
    if (medData.length > 0) {
      stepX.push(medData[0].datetime);
      stepY.push(medData[0].dose);
      for (let i = 1; i < medData.length; i++) {
        let prev = medData[i - 1];
        let curr = medData[i];
        stepX.push(curr.datetime);
        stepY.push(prev.dose);
        stepX.push(curr.datetime);
        stepY.push(curr.dose);
      }
      let now = new Date();
      if (now > medData[medData.length - 1].datetime) {
        stepX.push(now);
        stepY.push(medData[medData.length - 1].dose);
      }
    }
    let trace = {
      x: stepX,
      y: stepY,
      mode: "lines",
      type: "scatter",
      name: med,
      line: { shape: "hv" }
    };
    traces.push(trace);
  });
  
  // Determine x-axis range from xLabels, etc.
  let freq = document.querySelector("input[name='binning']:checked").value;
  let xMin, xMax;
  if (freq === "Daily") {
    xMin = new Date(xLabels[0]);
    xMax = new Date(xLabels[xLabels.length - 1]);
  } else if (freq === "Weekly") {
    xMin = parseISOWeek(xLabels[0]);
    xMax = parseISOWeek(xLabels[xLabels.length - 1]);
  } else if (freq === "Monthly") {
    xMin = parseYearMonth(xLabels[0]);
    xMax = parseYearMonth(xLabels[xLabels.length - 1]);
  }
  //console.log("xMin:", xMin, "xMax:", xMax);
  let layout = {
    title: "Medication Dose Over Time",
    xaxis: { title: "Date", type: "date", range: [xMin, xMax] },
    yaxis: { title: "Dose (mg)" },
    height: 400
  };
  Plotly.newPlot("medGraph", traces, layout);
}

function populateUserDropdown() {
  const dropdown = document.getElementById("userSelect");
  dropdown.innerHTML = ""; // Clear existing options
  
  // Add "All Users" option
  let allOption = document.createElement("option");
  allOption.value = "all";
  allOption.textContent = "All Users";
  dropdown.appendChild(allOption);
  
  // Get unique user IDs from globalData
  let userIds = [...new Set(globalData.map(row => row.id))].filter(id => id !== "Unknown").sort();
  
  // Add each user ID as an option
  userIds.forEach(id => {
    let option = document.createElement("option");
    option.value = id;
    option.textContent = `User ${id}`;
    dropdown.appendChild(option);
  });
  
  // Add "Unknown" option at the end if there are any entries with unknown ID
  if (globalData.some(row => row.id === "Unknown")) {
    let unknownOption = document.createElement("option");
    unknownOption.value = "Unknown";
    unknownOption.textContent = "Unknown User";
    dropdown.appendChild(unknownOption);
  }
  
  console.log("User dropdown updated with IDs:", userIds);
}

document.addEventListener("DOMContentLoaded", function() {
  // Bind Flatpickr to date inputs
  flatpickr("#startDate", {
    defaultDate: new Date(Date.now() - 365 * 24 * 60 * 60 * 1000),
    dateFormat: "Y-m-d",
    altInput: true,
    altFormat: "F j, Y",
    onReady: updateCharts,
    onChange: updateCharts
  });
  flatpickr("#endDate", {
    defaultDate: new Date(),
    dateFormat: "Y-m-d",
    altInput: true,
    altFormat: "F j, Y",
    onReady: updateCharts,
    onChange: updateCharts
  });
});

document.addEventListener("DOMContentLoaded", function() {
  // Bind file upload event listener:
  document.getElementById("fileUpload").addEventListener("change", handleFileUpload);

  // Bind example dataset buttons:
  document.getElementById("loadDefaultBtn").addEventListener("click", () => {
    loadExampleDataset(defaultFileUrl);
  });
  document.getElementById("loadExample1Btn").addEventListener("click", () => {
    loadExampleDataset("data/Simulated_Epilepsy_diary_1.xlsx");
  });
  document.getElementById("loadExample2Btn").addEventListener("click", () => {
    loadExampleDataset("data/Simulated_Epilepsy_diary_2.xlsx");
  });
  // Auto-load default dataset
  loadExampleDataset(defaultFileUrl);

  // Bind control events for remaining controls
  document.getElementById("seizureTypes").addEventListener("change", updateCharts);
  document.querySelectorAll("input[name='binning']").forEach(elem => {
    elem.addEventListener("change", updateCharts);
  });
  document.getElementById("analysisRange").addEventListener("change", () => {
    if (firstData || secondData) {
      updateDetailGraphs(null, null);
    }
  });

  document.getElementById("userSelect").addEventListener("change", function() {
    // Reset any selected regions on the heatmap when the user changes
    firstData = null;
    secondData = null;
    clearOverlays();
    
    // Update charts with the new user filter
    updateCharts();
    updateACFGraph()
  });

  document.getElementById("downloadTemplateBtn").addEventListener("click", function() {
  window.location.href = "data/Simulated_Epilepsy_diary_1.xlsx";
});

  // Bind Event Dependence tab controls
  const triggerDropdown = document.getElementById("triggerEvent");
  const responseDropdown = document.getElementById("responseEvent");
  const lagSlider = document.getElementById("lagSlider");
  if (triggerDropdown && responseDropdown && lagSlider) {
    triggerDropdown.addEventListener("change", runEventDependenceAnalysis);
    responseDropdown.addEventListener("change", runEventDependenceAnalysis);
    lagSlider.addEventListener("input", function() {
      document.getElementById("lagValue").textContent = this.value;
      runEventDependenceAnalysis();
    });
  } else {
    console.error("One or more Event Dependence controls not found in the DOM.");
  }
  
  // Initialize medication toggle button events
  initMedToggleButtons();
});
document.addEventListener("DOMContentLoaded", function() {
  const popoverTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]'));
  popoverTriggerList.map(function (popoverTriggerEl) {
    return new bootstrap.Popover(popoverTriggerEl);
  });


  
});

document.getElementById("acfLagSlider").addEventListener("input", function() {
  updateACFGraph();
});


function computeACF(data, maxLag) {
  const n = data.length;
  const mean = data.reduce((a, b) => a + b, 0) / n;
  const variance = data.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / n;
  const acf = [];
  for (let lag = 0; lag <= maxLag; lag++) {
    let cov = 0;
    for (let i = 0; i < n - lag; i++) {
      cov += (data[i] - mean) * (data[i + lag] - mean);
    }
    cov /= (n - lag);
    acf.push(cov / variance);
  }
  return acf;
}

function getDailyCounts(startDate, endDate) {
  let dailyMap = {};
  let cur = new Date(startDate);
  cur.setHours(0, 0, 0, 0);
  while (cur <= endDate) {
    dailyMap[formatYYYYMMDD(cur)] = 0;
    cur.setDate(cur.getDate() + 1);
  }
  globalData.forEach(item => {
    if (item.datetime >= startDate && item.datetime <= endDate) {
      let key = formatYYYYMMDD(item.datetime);
      if (dailyMap.hasOwnProperty(key)) {
        dailyMap[key]++;
      }
    }
  });
  // Return an array of counts in date order.
  return Object.values(dailyMap);
}

function updateACFGraph() {
  // Get the selected date range from the date inputs.
  let startDate = new Date(document.getElementById("startDate").value);
  let endDate = new Date(document.getElementById("endDate").value);
  
  // Get daily counts from the data.
  let dailyCounts = getDailyCounts(startDate, endDate);
  if (dailyCounts.length === 0) {
    Plotly.newPlot("acfGraph", [], { title: "No data for autocorrelation" });
    return;
  }
  
  // Get max lag in weeks from the slider and convert to days.
  let sliderVal = parseFloat(document.getElementById("acfLagSlider").value);
  document.getElementById("acfLagValue").textContent = sliderVal;
  let maxLagDays = Math.round(sliderVal * 7);
  
  // Compute autocorrelation up to the max lag.
  let acf = computeACF(dailyCounts, maxLagDays);
  
  // Create an array for the lags in weeks (convert days to weeks).
  let lagsInWeeks = acf.map((_, i) => i / 7);
  
  let trace = {
    x: lagsInWeeks,
    y: acf,
    mode: "lines+markers",
    type: "scatter",
    name: "Autocorrelation"
  };
  
  let layout = {
    title: "Autocorrelation (Periodicity)",
    xaxis: { title: "Lag (weeks)" },
    yaxis: { title: "ACF" },
    margin: { t: 40, b: 40 }
  };
  
  Plotly.newPlot("acfGraph", [trace], layout);
}


let heatmapMode = "count"; // global variable for heatmap mode

// Attach event listeners so only one button is active at a time.
document.querySelectorAll("#heatmapToggleGroup button").forEach(btn => {
  btn.addEventListener("click", function() {
    // Remove "active" class from all buttons in the group
    document.querySelectorAll("#heatmapToggleGroup button").forEach(b => b.classList.remove("active"));
    // Mark this button as active
    this.classList.add("active");
    // Update global mode based on the button's data attribute
    heatmapMode = this.getAttribute("data-mode");
    // Recalculate the charts (or just the heatmap if you prefer)
    updateCharts();
    updateACFGraph()
  });
});

</script>

</body>
</html>